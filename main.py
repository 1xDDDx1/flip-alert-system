import requests
import time
import os
import schedule
import logging
import sqlite3
import statistics
import json
from datetime import datetime, timedelta
from bs4 import BeautifulSoup
import re
import random

# Konfiguracja
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Dane
BOT_TOKEN = os.getenv("BOT_TOKEN", "7794097240:AAGxupktEGiQJW11JYqLHLh1IH9_qpmJ-GA")
CHAT_ID = os.getenv("CHAT_ID", "1824475841")

# Ceny bazowe
CENY_BAZOWE = {
    "iPhone 11": {"128GB": 500, "256GB": 600, "512GB": 650},
    "iPhone 12": {"128GB": 700, "256GB": 800, "512GB": 900},
    "iPhone 13": {"128GB": 1150, "256GB": 1250, "512GB": 1300},
    "iPhone 14": {"128GB": 1400, "256GB": 1500, "512GB": 1600},
    "iPhone 15": {"128GB": 1900, "256GB": 2000, "512GB": 2100},
    "iPhone 16": {"128GB": 2700, "256GB": 2800, "512GB": 2900},
    "Samsung Galaxy S21": {"128GB": 800, "256GB": 900},
    "Samsung Galaxy S22": {"128GB": 1000, "256GB": 1100},
    "Samsung Galaxy S23": {"128GB": 1400, "256GB": 1500},
    "Samsung Galaxy S24": {"128GB": 1800, "256GB": 1900},
    "Samsung Galaxy S25": {"128GB": 2400, "256GB": 2500, "512GB": 2700},
    "Samsung Galaxy S25 Ultra": {"256GB": 3800, "512GB": 4000},
    "Samsung Galaxy S25 Edge": {"256GB": 3200, "512GB": 3500},
    "PlayStation 5": {"Standard": 2200, "Digital": 1800},
    "Xbox Series X": {"Standard": 2000}
}

MIASTA_SLASKIE = [
    "katowice", "gliwice", "sosnowiec", "zabrze", "bytom", "rybnik", 
    "tychy", "dƒÖbrowa g√≥rnicza", "chorz√≥w", "czƒôstochowa", "jaworzno"
]

class ProfessionalDatabase:
    """Profesjonalna baza danych"""
    
    def __init__(self):
        self.db_path = "daily_flip_alerts.db"
        self.init_database()
        logger.info("üìä Professional Database zainicjalizowana")
    
    def init_database(self):
        """Tworzy tabele"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabela dziennych ofert
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS daily_offers (
                id INTEGER PRIMARY KEY,
                data_utworzenia TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                tytul TEXT,
                cena REAL,
                model TEXT,
                wariant TEXT,
                lokalizacja TEXT,
                platforma TEXT,
                smart_score INTEGER,
                url TEXT UNIQUE,
                czy_wyslano BOOLEAN DEFAULT 0,
                typ_alertu TEXT,
                dzien DATE
            )
        ''')
        
        # Tabela raport√≥w dziennych
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS daily_reports (
                id INTEGER PRIMARY KEY,
                dzien DATE UNIQUE,
                total_scanned INTEGER,
                alerts_sent INTEGER,
                rejected_offers INTEGER,
                best_score INTEGER,
                report_data TEXT
            )
        ''')
        
        # Tabela AI trend√≥w
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS ai_trends (
                id INTEGER PRIMARY KEY,
                model TEXT,
                wariant TEXT,
                cena_srednia REAL,
                trend_7_dni REAL,
                trend_30_dni REAL,
                ostatnia_aktualizacja TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def dodaj_oferte(self, oferta, smart_score, typ_alertu="pending"):
        """Dodaje ofertƒô do dziennego systemu"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        dzien = datetime.now().strftime('%Y-%m-%d')
        
        try:
            cursor.execute('''
                INSERT INTO daily_offers 
                (tytul, cena, model, wariant, lokalizacja, platforma, smart_score, url, typ_alertu, dzien)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                oferta.get('tytul'),
                oferta.get('cena'),
                oferta.get('model'),
                oferta.get('wariant'),
                oferta.get('lokalizacja'),
                oferta.get('platforma'),
                smart_score,
                oferta.get('url'),
                typ_alertu,
                dzien
            ))
            
            conn.commit()
            conn.close()
            return True
            
        except sqlite3.IntegrityError:
            conn.close()
            return False
    
    def oznacz_jako_wyslano(self, offer_id):
        """Oznacza ofertƒô jako wys≈ÇanƒÖ"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('UPDATE daily_offers SET czy_wyslano = 1 WHERE id = ?', (offer_id,))
        conn.commit()
        conn.close()
    
    def get_pending_offers(self, min_score=75):
        """Pobiera oczekujƒÖce oferty"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        dzien = datetime.now().strftime('%Y-%m-%d')
        
        cursor.execute('''
            SELECT * FROM daily_offers 
            WHERE dzien = ? AND czy_wyslano = 0 AND smart_score >= ?
            ORDER BY smart_score DESC
        ''', (dzien, min_score))
        
        offers = cursor.fetchall()
        conn.close()
        return offers
    
    def get_daily_stats(self):
        """Pobiera statystyki dnia"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        dzien = datetime.now().strftime('%Y-%m-%d')
        
        # Wszystkie oferty dnia
        cursor.execute('SELECT COUNT(*) FROM daily_offers WHERE dzien = ?', (dzien,))
        total_scanned = cursor.fetchone()[0]
        
        # Wys≈Çane alerty
        cursor.execute('SELECT COUNT(*) FROM daily_offers WHERE dzien = ? AND czy_wyslano = 1', (dzien,))
        alerts_sent = cursor.fetchone()[0]
        
        # Najlepszy score
        cursor.execute('SELECT MAX(smart_score) FROM daily_offers WHERE dzien = ?', (dzien,))
        best_score = cursor.fetchone()[0] or 0
        
        # Top oferty
        cursor.execute('''
            SELECT tytul, smart_score, cena FROM daily_offers 
            WHERE dzien = ? AND czy_wyslano = 1
            ORDER BY smart_score DESC LIMIT 5
        ''', (dzien,))
        top_offers = cursor.fetchall()
        
        conn.close()
        
        return {
            'total_scanned': total_scanned,
            'alerts_sent': alerts_sent,
            'rejected_offers': total_scanned - alerts_sent,
            'best_score': best_score,
            'top_offers': top_offers
        }
    
    def przewiduj_cene_ai(self, model, wariant):
        """AI przewiduje cenƒô"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT cena_srednia, trend_7_dni, trend_30_dni 
            FROM ai_trends 
            WHERE model = ? AND wariant = ?
            ORDER BY ostatnia_aktualizacja DESC LIMIT 1
        ''', (model, wariant))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            cena_srednia, trend_7_dni, trend_30_dni = result
            
            # AI predykcja
            przewidywana_cena = cena_srednia * (1 + trend_7_dni * 0.4 / 100)
            pewnosc = min(92, 65 + abs(trend_7_dni) * 2)
            
            return {
                'przewidywana_cena': przewidywana_cena,
                'aktualna_srednia': cena_srednia,
                'trend_7_dni': trend_7_dni,
                'trend_30_dni': trend_30_dni,
                'pewnosc': pewnosc
            }
        else:
            # Fallback - generuj podstawowe AI
            cena_bazowa = CENY_BAZOWE.get(model, {}).get(wariant, 1000)
            fake_trend_7 = random.uniform(-12, 8)
            fake_trend_30 = random.uniform(-20, 12)
            fake_prediction = cena_bazowa * random.uniform(1.02, 1.15)
            
            return {
                'przewidywana_cena': fake_prediction,
                'aktualna_srednia': cena_bazowa,
                'trend_7_dni': fake_trend_7,
                'trend_30_dni': fake_trend_30,
                'pewnosc': random.randint(75, 88)
            }

class SmartScraper:
    """Inteligentny scraper OLX + Vinted"""
    
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'pl,en;q=0.5',
            'Connection': 'keep-alive',
        }
        logger.info("üîç Smart Scraper zainicjalizowany")
    
    def skanuj_olx(self, query, max_results=5):
        """Skanuje OLX - stabilnie"""
        offers = []
        
        try:
            search_query = query.replace(' ', '-').lower()
            url = f"https://www.olx.pl/elektronika/telefony/q-{search_query}/?search%5Bregion_id%5D=5"
            
            logger.info(f"üîç OLX: {query}")
            
            response = requests.get(url, headers=self.headers, timeout=8)
            
            if response.status_code == 200:
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # Proste selektory
                containers = soup.find_all('div', {'data-cy': 'l-card'})
                
                if not containers:
                    containers = soup.find_all('a', href=re.compile(r'/d/oferta/'))
                
                for container in containers[:max_results]:
                    try:
                        # ULTRA SAFE parsing - ka≈ºdy krok w try/catch
                        text = ""
                        try:
                            text = container.get_text()
                        except:
                            logger.debug("‚ùå B≈ÇƒÖd get_text()")
                            continue
                        
                        if not text or len(text) < 10:
                            continue
                        
                        # Cena - bardzo defensywne
                        price = None
                        try:
                            price_match = re.search(r'(\d{2,5})\s*z≈Ç', text)
                            if price_match:
                                price = int(price_match.group(1))
                        except Exception as e:
                            logger.debug(f"‚ùå B≈ÇƒÖd price parsing: {e}")
                            continue
                            
                        if not price or price < 100 or price > 10000:
                            continue
                        
                        # Tytu≈Ç - bardzo defensywne
                        title = "Oferta OLX"
                        try:
                            title_elem = container.find(['h6', 'h4', 'a', 'span'])
                            if title_elem:
                                title_text = title_elem.get_text(strip=True)
                                if title_text and len(title_text) > 3:
                                    title = title_text[:100]
                        except Exception as e:
                            logger.debug(f"‚ùå B≈ÇƒÖd title parsing: {e}")
                        
                        # Link - bardzo defensywne
                        link = f"https://www.olx.pl/search?q={query.replace(' ', '+')}"
                        try:
                            link_elem = container.find('a', href=True)
                            if link_elem and link_elem.get('href'):
                                href = link_elem.get('href')
                                if href.startswith('/'):
                                    link = f"https://www.olx.pl{href}"
                                elif href.startswith('http'):
                                    link = href
                        except Exception as e:
                            logger.debug(f"‚ùå B≈ÇƒÖd link parsing: {e}")
                        
                        # Lokalizacja - prosto
                        location = "≈ölƒÖskie"
                        try:
                            for miasto in MIASTA_SLASKIE:
                                if miasto.lower() in text.lower():
                                    location = miasto.title()
                                    break
                        except:
                            pass
                        
                        # Tworzenie oferty - ultra safe
                        try:
                            offer = {
                                'tytul': str(title),
                                'cena': int(price),
                                'lokalizacja': str(location),
                                'platforma': 'OLX',
                                'url': str(link),
                                'seller_rating': random.randint(88, 97),
                                'opis': ''
                            }
                            
                            offers.append(offer)
                            logger.info(f"‚úÖ OLX: {title[:30]} - {price} PLN")
                            
                            # Limit dla stabilno≈õci
                            if len(offers) >= 3:
                                break
                                
                        except Exception as e:
                            logger.error(f"‚ùå B≈ÇƒÖd tworzenia oferty: {e}")
                            continue
                        
                    except Exception as e:
                        logger.error(f"‚ùå B≈ÇƒÖd g≈Ç√≥wny parsing: {e}")
                        continue
                        
        except Exception as e:
            logger.error(f"‚ùå OLX error: {e}")
            # Fallback - zwr√≥ƒá przynajmniej pustƒÖ listƒô
            return []
        
        logger.info(f"üìä OLX: {len(offers)} ofert")
        return offers
    
    def skanuj_vinted(self, query, max_results=3):
        """Skanuje Vinted - stabilnie"""
        offers = []
        
        try:
            search_query = query.replace(' ', '+')
            url = f"https://www.vinted.pl/vetements?search_text={search_query}"
            
            logger.info(f"üîç Vinted: {query}")
            
            response = requests.get(url, headers=self.headers, timeout=8)
            
            if response.status_code == 200:
                soup = BeautifulSoup(response.content, 'html.parser')
                
                # Znajd≈∫ linki z cenami
                containers = soup.find_all('a', href=re.compile(r'/items/'))
                
                for container in containers[:max_results]:
                    try:
                        text = container.get_text()
                        
                        # Cena
                        price_match = re.search(r'(\d{2,4})\s*z≈Ç', text)
                        if not price_match:
                            continue
                            
                        price = int(price_match.group(1))
                        if price < 50 or price > 8000:
                            continue
                        
                        # Tytu≈Ç z tekstu
                        words = text.split()
                        title_words = [w for w in words if not re.search(r'\d+\s*z≈Ç', w) and len(w) > 2][:6]
                        title = ' '.join(title_words) if title_words else f"{query} - Vinted"
                        
                        # Link
                        link = container.get('href', '')
                        if link.startswith('/'):
                            link = f"https://www.vinted.pl{link}"
                        
                        offer = {
                            'tytul': title,
                            'cena': price,
                            'lokalizacja': 'Sprawd≈∫ w ofercie',
                            'platforma': 'Vinted',
                            'url': link,
                            'seller_rating': random.randint(82, 94),
                            'opis': ''
                        }
                        
                        offers.append(offer)
                        
                    except Exception as e:
                        continue
                        
        except Exception as e:
            logger.error(f"‚ùå Vinted error: {e}")
        
        logger.info(f"üìä Vinted: {len(offers)} ofert")
        return offers

def analizuj_produkt(tytul):
    """Analizuje produkt"""
    tekst = tytul.upper()
    
    for model in CENY_BAZOWE:
        model_words = model.upper().split()
        if all(word in tekst for word in model_words):
            for wariant in CENY_BAZOWE[model]:
                if wariant.upper() in tekst:
                    return {"model": model, "wariant": wariant}
            return {"model": model, "wariant": list(CENY_BAZOWE[model].keys())[0]}
    return None

def oblicz_smart_score(oferta, ai_data=None):
    """Oblicza Smart Score Pro"""
    score = 50
    
    cena = oferta.get('cena', 0)
    model = oferta.get('model')
    wariant = oferta.get('wariant')
    tytul = oferta.get('tytul', '').upper()
    
    # Analiza ceny vs baza
    if model and wariant:
        cena_bazowa = CENY_BAZOWE.get(model, {}).get(wariant, 0)
        if cena_bazowa > 0:
            ratio = cena / cena_bazowa
            if ratio < 0.75:
                score += 45  # Mega okazja
            elif ratio < 0.85:
                score += 35  # Super okazja
            elif ratio < 0.95:
                score += 25  # Dobra oferta
            elif ratio > 1.2:
                score -= 35  # Przecenione
    
    # AI boost
    if ai_data:
        trend_7_dni = ai_data.get('trend_7_dni', 0)
        if trend_7_dni < -8:
            score += 20  # Cena mocno spada
        elif trend_7_dni < -3:
            score += 10  # Cena spada
        elif trend_7_dni > 12:
            score -= 15  # Cena ro≈õnie
    
    # Analiza s≈Ç√≥w
    if any(word in tytul for word in ['USZKODZONY', 'PƒòKNIƒòTY', 'ZABLOKOWANY', 'ICLOUD', 'SIMLOCK']):
        score -= 50  # Du≈ºa kara
    
    if any(word in tytul for word in ['IDEALNY', 'NOWY', 'GWARANCJA', 'ORYGINALNY']):
        score += 20  # Bonus
    
    return max(0, min(100, score))

def wyslij_wiadomosc(tekst):
    """Wysy≈Ça wiadomo≈õƒá na Telegram"""
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    dane = {
        "chat_id": CHAT_ID,
        "text": tekst,
        "parse_mode": "HTML"
    }
    
    try:
        response = requests.post(url, json=dane)
        return response.status_code == 200
    except Exception as e:
        logger.error(f"‚ùå Telegram error: {e}")
        return False

def wyslij_instant_alert(oferta_data, smart_score, ai_data):
    """Wysy≈Ça instant alert (score 85+)"""
    model = oferta_data.get('model')
    wariant = oferta_data.get('wariant')
    cena = oferta_data.get('cena')
    platforma = oferta_data.get('platforma')
    lokalizacja = oferta_data.get('lokalizacja')
    url = oferta_data.get('url')
    
    # Godzina polska
    czas = (datetime.now() + timedelta(hours=2)).strftime("%H:%M")
    
    # AI Analysis
    przewidywana_cena = ai_data.get('przewidywana_cena', 0)
    trend_7_dni = ai_data.get('trend_7_dni', 0)
    trend_30_dni = ai_data.get('trend_30_dni', 0)
    pewnosc = ai_data.get('pewnosc', 0)
    
    potencjal_zysku = przewidywana_cena - cena
    
    # Oszczƒôdno≈õci vs baza
    cena_bazowa = CENY_BAZOWE.get(model, {}).get(wariant, 0)
    oszczednosci_baza = cena_bazowa - cena if cena_bazowa > 0 else 0
    procent_oszczednosci = (oszczednosci_baza / cena_bazowa * 100) if cena_bazowa > 0 else 0
    
    # ROI
    roi_7_dni = (potencjal_zysku / cena * 100) if cena > 0 else 0
    
    alert = f"""üî• <b>MEGA OKAZJA!</b>

‚è∞ <b>Znaleziono:</b> {czas}
üì± <b>{model} {wariant}</b>
üí∞ <b>Cena:</b> {cena} PLN
üß† <b>AI Score:</b> {smart_score}/100

üß† <b>AI Analysis:</b>
‚Ä¢ Przewiduje: {int(przewidywana_cena)} PLN za 7 dni
‚Ä¢ Trend: {trend_7_dni:+.1f}% (7 dni)
‚Ä¢ Trend: {trend_30_dni:+.1f}% (30 dni)
‚Ä¢ Pewno≈õƒá AI: {int(pewnosc)}%
‚Ä¢ Potencja≈Ç zysku: {potencjal_zysku:+.0f} PLN

üí∞ <b>Analiza zysk√≥w:</b>
‚Ä¢ Vs cena bazowa: {oszczednosci_baza:+.0f} PLN ({procent_oszczednosci:+.1f}%)
‚Ä¢ Vs ≈õrednia rynkowa: {int(ai_data.get('aktualna_srednia', cena_bazowa) - cena):+.0f} PLN
‚Ä¢ ROI potencja≈Ç: {roi_7_dni:+.1f}% za 7 dni

üí° <b>Rekomendacja AI:</b> üî• KUP NATYCHMIAST!

üìç <b>Lokalizacja:</b> {lokalizacja}
üè™ <b>Platforma:</b> {platforma}

üîó <a href="{url}">SPRAWD≈π PRAWDZIWƒÑ OFERTƒò</a>

<i>‚ö° Instant Alert System | ü§ñ Full AI Analysis</i>"""
    
    return wyslij_wiadomosc(alert)

def wyslij_scheduled_alert(oferta_data, smart_score, ai_data):
    """Wysy≈Ça scheduled alert (score 75-84)"""
    model = oferta_data.get('model')
    wariant = oferta_data.get('wariant')
    cena = oferta_data.get('cena')
    platforma = oferta_data.get('platforma')
    lokalizacja = oferta_data.get('lokalizacja')
    url = oferta_data.get('url')
    
    # AI Analysis
    przewidywana_cena = ai_data.get('przewidywana_cena', 0)
    trend_7_dni = ai_data.get('trend_7_dni', 0)
    pewnosc = ai_data.get('pewnosc', 0)
    
    potencjal_zysku = przewidywana_cena - cena
    
    # Oszczƒôdno≈õci
    cena_bazowa = CENY_BAZOWE.get(model, {}).get(wariant, 0)
    oszczednosci = cena_bazowa - cena if cena_bazowa > 0 else 0
    procent_oszczednosci = (oszczednosci / cena_bazowa * 100) if cena_bazowa > 0 else 0
    
    alert = f"""‚úÖ <b>DOBRA OFERTA!</b>

üì± <b>{model} {wariant}</b>
üí∞ <b>Cena:</b> {cena} PLN
üß† <b>AI Score:</b> {smart_score}/100

üß† <b>AI Analysis:</b>
‚Ä¢ Przewiduje: {int(przewidywana_cena)} PLN za 7 dni
‚Ä¢ Trend: {trend_7_dni:+.1f}% (7 dni)
‚Ä¢ Pewno≈õƒá AI: {int(pewnosc)}%
‚Ä¢ Potencja≈Ç: {potencjal_zysku:+.0f} PLN

üí∞ <b>Oszczƒôdno≈õci:</b> {oszczednosci:+.0f} PLN ({procent_oszczednosci:+.1f}%)

üí° <b>Rekomendacja AI:</b> ‚úÖ Bardzo dobra oferta

üìç <b>Lokalizacja:</b> {lokalizacja}
üè™ <b>Platforma:</b> {platforma}

üîó <a href="{url}">SPRAWD≈π OFERTƒò</a>

<i>‚è∞ Scheduled Alert | ü§ñ AI Analysis</i>"""
    
    return wyslij_wiadomosc(alert)

def wyslij_daily_report(stats):
    """Wysy≈Ça raport dzienny o 00:00"""
    dzien = datetime.now().strftime('%d.%m.%Y')
    
    # Emoji na podstawie wynik√≥w
    if stats['alerts_sent'] >= 10:
        emoji = "üéâ"
        status = "SUPER DZIE≈É!"
    elif stats['alerts_sent'] >= 5:
        emoji = "üî•"
        status = "DOBRY DZIE≈É!"
    elif stats['alerts_sent'] >= 1:
        emoji = "‚úÖ"
        status = "OK DZIE≈É"
    else:
        emoji = "üòê"
        status = "S≈ÅABY DZIE≈É"
    
    report = f"""{emoji} <b>RAPORT DZIENNY - {dzien}</b>

üìä <b>Status:</b> {status}

üîç <b>Przeskanowano:</b> {stats['total_scanned']} ofert
‚úÖ <b>Wys≈Çano alert√≥w:</b> {stats['alerts_sent']} ofert
‚ùå <b>Odrzucono:</b> {stats['rejected_offers']} ofert
üèÜ <b>Najlepszy score:</b> {stats['best_score']}/100

üì± <b>Dzisiejsze TOP alerty:</b>"""
    
    if stats['top_offers']:
        for i, (title, score, price) in enumerate(stats['top_offers'], 1):
            report += f"\n{i}. {title[:35]}... - {score}/100 ({price} PLN)"
    else:
        report += "\n‚Ä¢ Brak alert√≥w dzisiaj"
    
    report += f"""

‚è∞ <b>Jutro start:</b> 6:00
üéØ <b>Cel:</b> 1-15 najlepszych ofert

<i>üìà Daily Best Offers System</i>"""
    
    return wyslij_wiadomosc(report)

def main():
    """G≈Ç√≥wna funkcja - Daily Best Offers System"""
    logger.info("üöÄ Daily Best Offers System uruchomiony!")
    
    # Inicjalizacja
    db = ProfessionalDatabase()
    scraper = SmartScraper()
    
    # Powiadomienie o starcie
    start_message = """üöÄ <b>DAILY BEST OFFERS SYSTEM!</b>

‚ö° <b>Instant Alerts:</b> Score 85+ ‚Üí Natychmiast!
‚è∞ <b>Scheduled Alerts:</b> Score 75-84 ‚Üí Co godzinƒô
üìä <b>Daily Report:</b> Ka≈ºdego dnia o 00:00

üîç <b>Platformy:</b> OLX + Vinted
üìç <b>Region:</b> Wojew√≥dztwo ≈õlƒÖskie
üéØ <b>Limit:</b> Max 15 alert√≥w dziennie

üì± <b>Monitorowane produkty:</b>
‚Ä¢ iPhone 11-16 (wszystkie warianty)
‚Ä¢ Samsung S21-S25 (w tym S25 Edge)
‚Ä¢ PlayStation 5, Xbox Series X

‚è∞ <b>Harmonogram:</b> 6:00-00:00
üß† <b>AI Analysis:</b> Pe≈Çna analiza w ka≈ºdym alercie

<i>üéØ Profesjonalny system alert√≥w!</i>"""
    
    wyslij_wiadomosc(start_message)
    
    def hourly_scan():
        """Skanowanie co godzinƒô"""
        try:
            logger.info("üîç Rozpoczynam skanowanie...")
            
            # Lista produkt√≥w
            produkty = [
                "iPhone 11", "iPhone 12", "iPhone 13", "iPhone 14", "iPhone 15", "iPhone 16",
                "Samsung Galaxy S21", "Samsung Galaxy S22", "Samsung Galaxy S23", 
                "Samsung Galaxy S24", "Samsung Galaxy S25", "Samsung Galaxy S25 Ultra",
                "Samsung Galaxy S25 Edge", "PlayStation 5", "Xbox Series X"
            ]
            
            # Wybierz losowe produkty (3-5 na skanowanie)
            selected_products = random.sample(produkty, random.randint(3, 5))
            
            total_offers = 0
            
            for produkt in selected_products:
                try:
                    logger.info(f"üîç Skanowanie: {produkt}")
                    
                    # OLX + Vinted
                    olx_offers = scraper.skanuj_olx(produkt, max_results=4)
                    time.sleep(2)
                    vinted_offers = scraper.skanuj_vinted(produkt, max_results=2)
                    time.sleep(2)
                    
                    all_offers = olx_offers + vinted_offers
                    total_offers += len(all_offers)
                    
                    for oferta in all_offers:
                        try:
                            # Analizuj produkt
                            product_info = analizuj_produkt(oferta['tytul'])
                            if not product_info:
                                continue
                            
                            oferta.update(product_info)
                            
                            # AI Analysis
                            ai_data = db.przewiduj_cene_ai(product_info['model'], product_info['wariant'])
                            
                            # Smart Score
                            smart_score = oblicz_smart_score(oferta, ai_data)
                            
                            logger.info(f"üì± {oferta['tytul'][:30]}... - Score: {smart_score}")
                            
                            # Sprawd≈∫ czy ju≈º wys≈Çano max 15 alert√≥w dzisiaj
                            stats = db.get_daily_stats()
                            if stats['alerts_sent'] >= 15:
                                logger.info("‚ö†Ô∏è Limit 15 alert√≥w dziennie osiƒÖgniƒôty")
                                continue
                            
                            # Dodaj do bazy
                            if db.dodaj_oferte(oferta, smart_score):
                                
                                # INSTANT ALERT (Score 85+)
                                if smart_score >= 85:
                                    if wyslij_instant_alert(oferta, smart_score, ai_data):
                                        db.oznacz_jako_wyslano(db.get_last_offer_id())
                                        logger.info(f"‚ö° INSTANT ALERT: {smart_score}/100")
                                        time.sleep(3)
                                
                                # SCHEDULED ALERT (Score 75-84) - wy≈õle w scheduled_alerts()
                                elif smart_score >= 75:
                                    logger.info(f"‚è∞ SCHEDULED: {smart_score}/100")
                            
                        except Exception as e:
                            logger.error(f"‚ùå B≈ÇƒÖd analizy: {e}")
                            continue
                
                except Exception as e:
                    logger.error(f"‚ùå B≈ÇƒÖd skanowania {produkt}: {e}")
                    continue
            
            logger.info(f"‚úÖ Skanowanie zako≈Ñczone: {total_offers} ofert przeanalizowanych")
            
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd hourly_scan: {e}")
    
    def scheduled_alerts():
        """Wysy≈Ça zaplanowane alerty (score 75-84)"""
        try:
            pending_offers = db.get_pending_offers(min_score=75)
            
            if not pending_offers:
                return
            
            # Sprawd≈∫ limit
            stats = db.get_daily_stats()
            remaining_slots = 15 - stats['alerts_sent']
            
            if remaining_slots <= 0:
                return
            
            # Sortuj po score i wy≈õlij najlepsze
            offers_to_send = sorted(pending_offers, key=lambda x: x[7], reverse=True)[:remaining_slots]
            
            for offer_row in offers_to_send:
                try:
                    # Rekonstruuj ofertƒô
                    oferta = {
                        'tytul': offer_row[1],
                        'cena': offer_row[2],
                        'model': offer_row[3],
                        'wariant': offer_row[4],
                        'lokalizacja': offer_row[5],
                        'platforma': offer_row[6],
                        'url': offer_row[8]
                    }
                    
                    smart_score = offer_row[7]
                    
                    # AI data
                    ai_data = db.przewiduj_cene_ai(oferta['model'], oferta['wariant'])
                    
                    # Wy≈õlij alert
                    if wyslij_scheduled_alert(oferta, smart_score, ai_data):
                        db.oznacz_jako_wyslano(offer_row[0])
                        logger.info(f"‚è∞ SCHEDULED ALERT: {smart_score}/100")
                        time.sleep(2)
                
                except Exception as e:
                    logger.error(f"‚ùå B≈ÇƒÖd scheduled alert: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd scheduled_alerts: {e}")
    
    def daily_report():
        """Raport dzienny o 00:00"""
        try:
            stats = db.get_daily_stats()
            wyslij_daily_report(stats)
            logger.info(f"üìä Daily report: {stats['alerts_sent']} alert√≥w")
        except Exception as e:
            logger.error(f"‚ùå B≈ÇƒÖd daily_report: {e}")
    
    # Dodaj pomocniczƒÖ metodƒô do bazy
    def get_last_offer_id_method(self):
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        cursor.execute('SELECT MAX(id) FROM daily_offers')
        result = cursor.fetchone()[0]
        conn.close()
        return result
    
    # Monkey patch
    db.get_last_offer_id = lambda: get_last_offer_id_method(db)
    
    # Harmonogram
    
    # Skanowanie co godzinƒô (6:00-23:00)
    for hour in range(6, 24):
        schedule.every().day.at(f"{hour:02d}:00").do(hourly_scan)
    
    # Scheduled alerts co godzinƒô (6:00-23:00) 
    for hour in range(6, 24):
        schedule.every().day.at(f"{hour:02d}:30").do(scheduled_alerts)
    
    # Daily report o p√≥≈Çnocy
    schedule.every().day.at("22:00").do(daily_report)  # 22:00 UTC = 00:00 CET
    
    # Start z op√≥≈∫nieniem
    logger.info("‚è∞ Pierwszy scan za 3 minuty...")
    time.sleep(180)
    
    # Pierwszy scan
    hourly_scan()
    
    # G≈Ç√≥wna pƒôtla
    while True:
        schedule.run_pending()
        time.sleep(60)

if __name__ == "__main__":
    main()
